= DDEX

DDEX metadata serialization

<b>DO NOT USE, WORK IN PROGRESS</b>

=== Overview

 require "ddex/ern"

 message = DDEX::ERN.read("path/to/metadata.xml")
 p message.update_indicator
 message.resources.each do |resource|
   p resource.title
   p resource.details.size
 end

 include DDEX::ERN::V341   # v3.4.1
 message = NewReleaseMessage.new(hash)
 record  = SoundRecording.new
 record.language_and_script_code = "en-US"
 # ...

 image = Image.new
 image.type = "FrontCoverImage"
 # ...

 message.resource_list << image
 message.resource_list << record
 xml = DDEX::ERN.write(message)

 details = TechnicalSoundRecordingDetails.new(hash)
 p details.to_hash
 puts details.to_xml

=== Where this differs from the spec

Every DDEX version handled by this module is fully supported, but there are some things you'll need to know.

==== Naming conventions

DDEX elements and attributes use the {CamelCase naming convention}[https://en.wikipedia.org/wiki/CamelCase], this module uses Ruby naming conversions: 
CamelCase for classes, and {snake_case}[https://en.wikipedia.org/wiki/Snake_case] for class attributes. For example, this DDEX XML:

  <PartyName>
    <FullName>sshaw</FullName>
  </PartyName>

Would be manipulated using via:

  party = PartyName.new(:full_name => "sshaw")
  puts party.full_name  
  party.full_name = "gwozdzie"
  
==== Cardinally

Elements that _can_ occur more than once will be placed in an <code>Array</code> and the parent class' accessor method will use the plural form of 
the element/attribute's name. For example:

  <Release>
    <!-- More data -->
    <PLine>
      <Year>1994</Year>
      <PLineText>Track Copyright</PLineText>
    </PLine>
    <PLine>
      <Year>2001</Year>
      <PLineText>Another Track Copyright</PLineText>
    </PLine>
  </Release>

Would be manipulated via:

  release.p_lines.each { |line| puts line.p_line_text }
  release.p_lines << PLine.new(:year => 1999)

<b>There are a few --hopefully obvious-- exceptions</b>. If the DDEX name indicates that its a collection, it's left alone.
+SoundRecordingDetailsByTerritory+ and +ResourceList+ come to mind.

==== Boolean elements and atrributes

+IsEan+ = +ean?+

TODO: See Types 

==== Version specific changes

===== ERN v3.6

<code>ern:PriceInformation/@PriceType</code> has been renamed to <code>@Type</code> to avoid conflicting with the element of the same


==== ERN version and schema

  DDEX::ERN.version = "3.5.1"

A version must have a configuration that describes the important XML attributes. These can be added/modified as necessary:

  cfg = DDEX::ERN.config[ DDEX::ERN.version ]
  p cfg[:namespace]
  p cfg[:schema_location]
  p cfg[:message_schema_location_id]

  DDEX::ERN.config["3.2"][:schema_location] = "somethang_custom"

=== TODO

Many things... but: ROXML.from_xml does not check the root element's name. Need to add something like:

  raise "unknown element #{xml.name}" unless xml.name == tag_name